parsingTable = [[0  ,1  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ], 
                [0  ,0  ,2  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,3  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [107,107,0  ,0  ,0  ,0  ,0  ,5  ,107,107,0  ,107,0  ,107,0  ,0  ,0  ,0  ,0  ,0  ,0  ,4  ,0  ,0  ,0  ,0  ,0  ],
                [-1 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,102,0  ,0  ,0  ,102,102,0  ,0  ,102,0  ,0  ,0  ,102,0  ,0  ,0  ,0  ,6  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,12 ,0  ,0  ,0  ,14 ,15 ,0  ,0  ,11 ,0  ,0  ,0  ,13 ,0  ,0  ,0  ,0  ,0  ,8  ,10 ,0  ,7  ,9  ,0  ,0  ,0  ],
                [0  ,12 ,0  ,0  ,0  ,0  ,0  ,0  ,16 ,11 ,0  ,0  ,0  ,13 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,17 ,0  ,0  ,0  ], 
                [0  ,101,0  ,0  ,0  ,101,101,0  ,0  ,101,0  ,0  ,0  ,101,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,109,0  ,0  ,0  ,0  ,0  ,0  ,109,109,0  ,0  ,0  ,109,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,18 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,23 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,22 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,19 ,20 ,21 ],
                [0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,24 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,23 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,22 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,25 ,21 ],
                [0  ,104,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,105,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [106,106,0  ,0  ,0  ,0  ,0  ,0  ,106,106,0  ,106,0  ,106,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,108,0  ,0  ,0  ,0  ,0  ,0  ,108,108,0  ,0  ,0  ,108,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,26 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,27 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,28 ,29 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,115,0  ,0  ,0  ,0  ,0  ,115,0  ,0  ,0  ,115,115,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,116,0  ,0  ,0  ,0  ,0  ,116,0  ,0  ,0  ,116,116,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,117,0  ,0  ,0  ,0  ,0  ,117,0  ,0  ,0  ,117,117,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,23 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,22 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,30 ,21 ],
                [0  ,0  ,0  ,0  ,31 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,29 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,103,0  ,0  ,0  ,103,103,0  ,0  ,103,0  ,0  ,0  ,103,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [107,107,0  ,0  ,0  ,0  ,0  ,5  ,107,107,0  ,107,0  ,107,0  ,0  ,0  ,0  ,0  ,0  ,0  ,32 ,0  ,0  ,0  ,0  ,0  ],
                [0  ,23 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,22 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,33 ,21 ],
                [0  ,23 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,22 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,34 ],
                [0  ,0  ,0  ,0  ,35 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,29 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,112,0  ,0  ,0  ,0  ,0  ,0  ,112,112,0  ,0  ,0  ,112,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,36 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,113,0  ,0  ,0  ,0  ,29 ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,0  ,0  ,0  ,114,0  ,0  ,0  ,0  ,0  ,114,0  ,0  ,0  ,114,114,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [0  ,111,0  ,0  ,0  ,0  ,0  ,0  ,111,111,0  ,0  ,0  ,111,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ],
                [107,107,0  ,0  ,0  ,0  ,0  ,5  ,107,107,0  ,107,0  ,107,0  ,0  ,0  ,0  ,0  ,0  ,0  ,37 ,0  ,0  ,0  ,0  ,0  ],
                [0  ,110,0  ,0  ,0  ,0  ,0  ,0  ,110,110,0  ,0  ,0  ,110,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ]]

class Node(object):
    def __init__(self, type):
        self.type = type
        self.children = []

    def add_child(self, children):
        for i in range(0, len(children)):
            self.children.append(children[i])

    def print_child(self):
        print("print_child: " + str(self.type))
        for i in self.children:
            print(i.type)
        for i in self.children:
            i.print_child()

class Nodes:
    def __init__(self):
        self.node_stack = []     

    def top(self):
        return self.node_stack[0]
    
    def parse_shift(self, token):
        self.node_stack.insert(0, Node(token))

    def parse_reduce(self, lhs, rhs):
        result = 1
        children = []
        rhsN = len(rhs)
        for i in range(0, rhsN):
            tmp = self.node_stack.pop(0)
            if tmp.type != rhs[rhsN-i-1][1]:
                '''print("reduce error")
                print(tmp.type)
                print(tmp)
                print(rhs[i][1])'''
                result = 0
                break
            children.insert(0, tmp)
        self.node_stack.insert(0, Node(lhs))
        if rhsN != 0: 
            self.top().add_child(children)
        return result
        
    def printNodes(self):
        for i in range(0, len(self.node_stack)):
            print(self.node_stack[i].type)

class parser(object):
    def __init__(self, tokens):
        #word aopen aclose bopen word "=" num ";" bclose
        self.input = tokens
        #self.input = [[1, -1, 'hi'], [2, -1, None], [3, -1, None], [7, -1, None],
        #              [1, -1, 'answer'], [12, -1, None], [16, 1, None], [4, -1, None], [8, -1, None]]
        self.stack = [[0, "$"]]
        self.state = 0
        self.error = False
        self.accept = False
        self.parsedTree = None
        self.nodes = Nodes()

    def shift(self, shift_num):
        from_input = self.input.pop(0)
        to_stack = [shift_num, from_input]
        self.stack.insert(0, to_stack)
        self.state = shift_num
        self.nodes.parse_shift(from_input)

    def reduce(self, reduce_num):
        goto_num = 17
        rhs = []
        if reduce_num == 0:
            # prog -> word aopen aclose block
            goto_num = 17
            rhs.insert(0, self.stack.pop(0))  # pop block
            rhs.insert(0, self.stack.pop(0))  # pop aclose
            rhs.insert(0, self.stack.pop(0))  # pop aopen
            rhs.insert(0, self.stack.pop(0))  # pop word
        elif reduce_num == 1:
            # decls -> decls decl
            goto_num = 18
            rhs.insert(0, self.stack.pop(0))  # pop decl
            rhs.insert(0, self.stack.pop(0))  # pop decls
        elif reduce_num == 2:
            # decls -> e
            goto_num = 18
        elif reduce_num == 3:
            # decl -> vtype word ";"
            goto_num = 19
            rhs.insert(0, self.stack.pop(0))  # pop ";"
            rhs.insert(0, self.stack.pop(0))  # pop word
            rhs.insert(0, self.stack.pop(0))  # pop vtype
        elif reduce_num == 4:
            # vtype -> int
            goto_num = 20
            rhs.insert(0, self.stack.pop(0))  # pop int
        elif reduce_num == 5:
            # vtype -> char
            goto_num = 20
            rhs.insert(0, self.stack.pop(0))  # pop char
        elif reduce_num == 6:
            # block -> bopen decls slist bclose
            goto_num = 21
            rhs.insert(0, self.stack.pop(0))  # pop bclose
            rhs.insert(0, self.stack.pop(0))  # pop slist
            rhs.insert(0, self.stack.pop(0))  # pop decls
            rhs.insert(0, self.stack.pop(0))  # pop bopen
        elif reduce_num == 7:
            # block -> e
            goto_num = 21
        elif reduce_num == 8:
            # slist -> slist stat
            goto_num = 22
            rhs.insert(0, self.stack.pop(0))  # pop stat
            rhs.insert(0, self.stack.pop(0))  # pop slist
        elif reduce_num == 9:
            # slist -> stat
            goto_num = 22
            rhs.insert(0, self.stack.pop(0))  # pop stat
        elif reduce_num == 10:
            # stat -> IF cond THEN block ELSE block
            goto_num = 23
            rhs.insert(0, self.stack.pop(0))  # pop block
            rhs.insert(0, self.stack.pop(0))  # pop ELSE
            rhs.insert(0, self.stack.pop(0))  # pop block
            rhs.insert(0, self.stack.pop(0))  # pop THEN
            rhs.insert(0, self.stack.pop(0))  # pop cond
            rhs.insert(0, self.stack.pop(0))  # pop IF
        elif reduce_num == 11:
            # stat -> word "=" expr ";"
            goto_num = 23
            rhs.insert(0, self.stack.pop(0))  # pop ";"
            rhs.insert(0, self.stack.pop(0))  # pop expr
            rhs.insert(0, self.stack.pop(0))  # pop "="
            rhs.insert(0, self.stack.pop(0))  # pop word
        elif reduce_num == 12:
            # stat -> EXIT expr ";"
            goto_num = 23
            rhs.insert(0, self.stack.pop(0))  # pop ";"
            rhs.insert(0, self.stack.pop(0))  # pop expr
            rhs.insert(0, self.stack.pop(0))  # pop EXIT
        elif reduce_num == 13:
            # cond -> expr ">" expr
            goto_num = 24
            rhs.insert(0, self.stack.pop(0))  # pop expr
            rhs.insert(0, self.stack.pop(0))  # pop ">"
            rhs.insert(0, self.stack.pop(0))  # pop expr
        elif reduce_num == 14:
            # expr -> expr "+" fact
            goto_num = 25
            rhs.insert(0, self.stack.pop(0))  # pop fact
            rhs.insert(0, self.stack.pop(0))  # pop "+"
            rhs.insert(0, self.stack.pop(0))  # pop expr
        elif reduce_num == 15:
            # expr -> fact
            goto_num = 25
            rhs.insert(0, self.stack.pop(0))  # pop fact
        elif reduce_num == 16:
            # fact -> num
            goto_num = 26
            rhs.insert(0, self.stack.pop(0))  # pop num
        elif reduce_num == 17:
            # fact -> word
            goto_num = 26
            rhs.insert(0, self.stack.pop(0))  # pop word

        state_num = self.stack[0][0]
        sNum_to_stack = parsingTable[state_num][goto_num]
        print("state num: " + str(state_num) + " goto_num: "+ str(goto_num) + " sNum_to_stack: " + str(sNum_to_stack))

        if sNum_to_stack == 0:
            self.error = True

        to_stack = [sNum_to_stack, [goto_num, -1]]
        self.stack.insert(0, to_stack)
        result = self.nodes.parse_reduce([goto_num, -1], rhs)

        if result == 0: 
            self.error = True

    def parse(self):
        self.input.append('$')
        self.accept=False
        self.reject=False
        self.error=False

        while self.accept == False:
            '''print("stack:")
            print(self.stack)
            print("input:")
            print(self.input)
            print("nodes:")
            self.nodes.printNodes()
            print("state: "+str(self.state))
            print("")
            print(self.stack)'''
            if self.error == True:
                break
            self.state = self.stack[0][0]
            reading = self.input[0][0]

            state_ = -1
            if reading == '$':
                state_ = parsingTable[self.state][0]
            else:
                state_ = parsingTable[self.state][reading]

            if state_ == -1:
                self.reduce(0)
                self.accept = True
            elif state_ == 0:
                self.error = True
            elif state_ < 100:
                self.shift(state_)
            elif state_ >= 101 and state_ <= 117:
                self.reduce(state_-100)
            
        print("accept: "+str(self.accept))
        self.parsedTree = self.nodes.top()
        '''
        (for debugging)
        print(self.parsedTree.type)
        self.parsedTree.print_child()
        '''

